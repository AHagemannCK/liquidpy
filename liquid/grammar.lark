start: tag*

?tag: whole_tag | end_tag | start_tag | output_tag | literal_tag | literal_start_tag

whole_tag: RAW_TAG | COMMENT_TAG
end_tag: OPEN_BRACE "end" VAR CLOSE_BRACE
output_tag: OPEN_OUTPUT output CLOSE_OUTPUT
start_tag: OPEN_BRACE inner_tag CLOSE_BRACE
// a better way?
literal_tag: /(?<=[%\}]\})((?![\}%]\}).)+?(?=\{[\{%]|$)/s
literal_start_tag: /^((?![\}%]\}).)+?(?=\{[\{%]|$)/s
// a better way?
RAW_TAG.4: /\{%-?\s*raw\s*-?%\}.*?\{%-?\s*endraw\s*-?%\}/s
COMMENT_TAG.4: /\{%-?\s*comment\s*-?%\}.*?\{%-?\s*endcomment\s*-?%\}/s

// tags
?inner_tag:

// expr too broad for output? maybe atom?
output: expr ("|" expr_filter)*

?expr_filter: filter [":" filter_args]

filter: VAR
filter_args: expr ("," expr)*

// liquid does not have a good support precedence of and / or
// if we have more than 3 operators
// however, with 3 operators, and has higher precedence
// see https://shopify.github.io/liquid/basics/operators/#order-of-operations

?expr: expr_nological (/and|or/ expr_nological)+ -> logical
    | expr_nological
    | "(" expr ")"

// we have to use earley to make this priority work
// liquid does not support parentheses, here we just add in case
?expr_nological: op_comparison
//    | contains
    | atom

op_comparison: atom OP atom
//!contains: atom "contains" atom

?atom: RANGE -> range
    | number
    | string
    | "nil"   -> nil
    | "true"  -> true
    | "false" -> false
    | atom "[" atom "]"       -> getitem
    | atom "." ATTRNAME ["?"] -> getattr
    | var

var: VAR
int: INT
number: INT | FLOAT_NUMBER
string: STRING

// have to define this as a terminal
// since 1..a will get translated into getattr
// (1.).a
RANGE.3: "(" (INT | VAR) ".." (INT | VAR) ")"
// note the order here
OP: "<>"|"=="|">="|"<="|"!="|"<"|">"|"contains"
STRING: ESCAPED_STRING | ("'" _STRING_ESC_INNER "'")
// earley does support terminal priorities
ATTRNAME: /[A-Za-z_][\w_\-]*/
DEC_NUMBER: /[-+]?(0|[1-9]\d*)/
HEX_NUMBER: /[-+]?0x[\dA-Fa-f]*/
OCT_NUMBER: /[-+]?0o[0-7]*/
BIN_NUMBER : /[-+]?0b[0-1]*/
FLOAT_NUMBER.2: /[-+]?((\d+\.\d*|\.\d+)([Ee][-+]?\d+)?|\d+([Ee][-+]?\d+))/
INT: DEC_NUMBER | HEX_NUMBER | BIN_NUMBER | OCT_NUMBER

OPEN_BRACE: _OPEN_BRACE_COMPACT | _OPEN_BRACE
CLOSE_BRACE: _CLOSE_BRACE_COMPACT | _CLOSE_BRACE
OPEN_OUTPUT: _OPEN_OUTPUT_COMPACT | _OPEN_OUTPUT
CLOSE_OUTPUT: _CLOSE_OUTPUT_COMPACT | _CLOSE_OUTPUT

_OPEN_BRACE: "{%"
_OPEN_BRACE_COMPACT.2: "{%-"
_CLOSE_BRACE: "%}"
_CLOSE_BRACE_COMPACT.2: "-%}"
_OPEN_OUTPUT: "{{"
_OPEN_OUTPUT_COMPACT.2: "{{-"
_CLOSE_OUTPUT: "}}"
_CLOSE_OUTPUT_COMPACT.2: "-}}"

%import common.CNAME -> VAR
%import common.NEWLINE -> _NL
%import common (ESCAPED_STRING, _STRING_ESC_INNER, WS_INLINE)
%ignore WS_INLINE
